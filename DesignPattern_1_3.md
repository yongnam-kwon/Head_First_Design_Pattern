# 1. Strategy Pattern

> 알고리즘군(행동/기능 집합 & 달라지는 부분)을 정의하고, 
> 각각을 **캡슐화**(`FlyBehavior`, `QuackBehavior` 인터페이스와 구현 클래스)
> → 클라이언트(다양한 오리들 - ex. `MallardDuck`)와는 **독립적으로 & 유연하게 알고리즘 변경** 가능
>
> 관리가 용이하고 상황에 맞게 변경할 수 있는 유연한 디자인!



#### 문제 상황

> `Duck` 수퍼클래스를 통해 다양한 오리를 생성해야 하는 상황.
> 청둥오리, 원앙 같은 진짜 오리부터 고무오리, 나무오리 등 가짜 오리까지 수퍼 클래스를 확장하여 다양한 오리 클래스를 만들 수 있는데....

##### 상속으로 다양한 오리 클래스를 올바르게 만들 수 있을까?

- `01use_inheritance`
- 문제점?
  - 수퍼클래스의 한 메소드(기능)이 필요없는 다른 서브클래스들까지 해당 기능이 부여됨 (이는 곧 버그)
    - Ex.1 Duck을 상속한 모든 오리클래스들은 `fly()` 메소드 기능 부여
    - Ex.2 `RubberDuck` 클래스 구현 인스턴스가 날아다니네??;;
  - 그럼 `RubberDuck` 클래스에만 `fly()` 오버라이드 할까?
    - 새로운 다른 오리(Ex. `WoodDuck`)가 생긴다면, 또 다시 오버라이드해주어야 함...

##### 인터페이스가 해결책이 될 수 있을까?

- `02use_interface`
- 문제점?
  - 날면 안되는 오리 클래스들의 `fly()` 메서드를 오버라이드 하지 않기 위해...
    날 수 있는 오리 클래스들의 `fly()` 메소드를 일일이 구현해주어야 하는...



#### 해결

> 상속으로 인해 쓸데 없는 기능을 부여받지 않아도 되고,
> 인터페이스로 따로 떼어 implement를 해줌으로써 매 클래스마다 메서드를 오버라이드해주지 않아도 되는 방법??
> ▶ 달라지지 않는 부분은 건드리지 않고, 달라지는 부분만 유연하게 효율적으로 변경!!!

##### [디자인 원칙 1] 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.

- 바뀌는 부분은 따로 뽑아 **캡슐화**시킴 (ex. 나는 행동, 꽥꽥거리는 행동)
  → 바뀌지 않는 부분에는 영향을 미치지 않고 바뀌는 부분만 고치거나 확장할 수 있음!

  

##### [디자인 원칙 2] 구현이 아닌 인터페이스에 맞춰 프로그래밍한다.

- 나는 행동, 꽥꽥 행동을 Duck 클래스에서 구현하거나 서브클래스에서 별도로 구현하지 않음

  - ex. <interface> FlyBehavior ◁─ FlyWithWings / FlyNoWay

- `Duck` 클래스를 전혀 건드리지 않고 날아다니거나 꽥꽥거리는 다른 행동들도 추가 가능 & 재사용 가능

- 디자인원칙 1, 2: `03strategy_pattern`

  

##### [디자인 원칙 3] 상속이 아닌 구성을 활용한다.

- 상속과 구성은 클래스에 추가 속성이나 동작을 제공함
  - 상속: 클래스를 확장할 때 부모 클래스의 속성과 동작을 **상속**
    - public 및 protected 속성과 동작을 상속하며, 하위 클래스가 해당 동작을 재정의할 수 있음
  - **구성**: 클래스가 다른 클래스의 객체 멤버 데이터로 **포함**할 수 있음
    - 포함된 동작을 변경하거나 추가할 수는 없음
- 모든 오리 하위클래스는 나는/우는 행동을 상속 받는 것이 아니라 특정 행동객체로 구성됨으로써 행동이 부여된 것!



# 2. Observer Pattern

> 옵저버 패턴?
> 한 객체의 상태가 바뀌면, 그 객체에 의존하는 다른 객체들(옵저버)에게 연락이 가고, 
> 자동으로 내용이 갱신되는 일대다(1(주제 객체) : 多(옵저버 객체)) 의존성 정의 (옵저버는 주제에 의존!)



#### 문제 상황

> `WeatherData`객체를 통해 기상스테이션에서 기온/습도/기압 정보를 가져와
> 현재 조건, 기상 통계, 기상 예보 디스플레이 제공

##### 달라질 수 있는 부분을 캡슐화할 필요성

- `01bad_case`
- 현재 조건, 기상 통계, 기상 예보 이외의 새로운 Display를 추가하고자 한다면, 
  `measurementsChanged()` 메소드를 직접 건드려야 함!
  → 이런 바뀔 수 있는 부분을 **캡슐화**해야 함



#### 해결

> Display에 의존하는 `WeatherData` 객체에서 
> `WeatherData`(주제 객체)에 의존하는 옵저버의 형태로 (`02observer_pattern`)

- 주제 객체: 상태를 저장하고 지배하는 주체 & 데이터의 주인 ----------------------------- 1

- 옵저버: 주제 객체에서 데이터를 갱신해주기를 기다림 (pull) ---------------------------- 多

  

##### [디자인 원칙 4] 느슨한 결합: 서로 상호작용하는 객체 사이에서는 가능한 느슨하게 결합해야 한다.

- 상호작용 관계의 두 객체가 서로가 서로에 대해서 잘 모름
  - 주제: 옵저버가 특정 인터페이스(`Observer` 인터페이스)를 구현한다는 것만 알고 있음
    - 옵저버를 언제든지 새로 추가할 수 있음
  - 옵저버: 주제만 알고 주제만 바라봄. 주제야 데이터 줘... (기다림)
- 장점
  - 주제는 옵저버를 언제든지 새로 추가, 제거 가능
  - 새로운 형식의 옵저버(위의 Display)가 생성되어도 주제를 전혀 변경할 필요가 없음
  - 주제/옵저버가 변경되더라도 서로에게 영향을 미치지 않음
- `02observer_pattern`



# 3. Decorator Pattern

> 객체를 래핑하는 방식으로 다른 객체를 꾸밈
> → 우선 특정 음료 시작으로 데코레이터로 그 음료를 장식하여 새로운 음료 메뉴 생성



#### 문제 상황

> 원하는 음료를 커스터마이징하여 주문할 수 있는 앱

- `Beverage` 추상클래스 & 모든 음료는 이 추상클래스를 상속받음
  - 메뉴 수만큼의 많은 서브클래스가 생성될 것임
  - 휘핑크림, 두유 등의 옵션이 추가될 때마다 새로운 서브클래스를 만들어야 함 (ex. `VanillaLatteWithWhippingCreamAndSoyMilk`)
  - 만약 두유 가격이 상승한다면? → 두유 들어가는 모든 메뉴의 `cost()`를 수정해주어야 함;;
- `Beverage` 추상 클래스에 `soyMilk, whippingCream` 등의 옵션과 `hasSoyMild(), hasWhip()` 등의 메서드를 모두 정의해두고, 음료 메뉴들은 이를 상속받음
  - 슈퍼클래스에 이미 옵션의 가격이 있기 때문에 `~WithWhippingCream` 따위의 서브클래스를 생성 안해도 됨
    휘핑크림 추가하면 `hasWhip()`이 `true`가 되고, 조건에 따라 휘핑크림 가격이 `cost()`에서 더해짐
  - 하지만 허니자몽블랙티 메뉴도 모든 옵션과 메서드들을 상속받게 되는 비효율
  - 휘핑크림 3번 추가와 같은 옵션을 선택할 수 없음



#### 해결

##### [디자인 원칙 5] OCP: 클래스는 확장에 대해서 열려있어야 하지만, 코드 변경에 대해서는 닫혀있어야 한다.

- 기존 코드는 건드리지 않은 채로 확장을 통해 새로운 행동을 간단히 추가하는 것이 목표!
- 가장 바뀔 확률이 높은 부분을 중점적으로 살펴보고, 원칙 적용
  - 모든 부분에서 OCP 준수하려 하는 것은 쓸데없는 시간 낭비가 될 수 있고, 보통 불가능함.
- `02decorator_pattern`

![image-20210724093540834](C:\Users\LG\AppData\Roaming\Typora\typora-user-images\image-20210724093540834.png)





##### 이런 데코레이터 패턴은 어디에서 사용되고 있을까? : ex. `InputStream`







