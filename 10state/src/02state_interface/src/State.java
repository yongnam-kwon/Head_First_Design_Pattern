public interface State {
    void insertQuarter();
    void ejectQuarter();
    void turnCrank();
    void dispense();
}
/*
    각 상태를 직접 클래스에 대응시킴
        - 각 상태에 따른 행동을 별개의 클래스(캡슐화)로 국지화
        - 관리하기 힘든 if문 없앰
        - OCP
            . 각 상태는 변경에 대해서는 닫혀있고 (함부로 상태에 대한 변경을 할 수 없음)
            . 확장에 대해서는 열려 있음 (새로운 상태 쉽게 만들 수 있음)
    스테이트 패턴
        - 객체 내부 상태가 바뀜에 따라 객체의 행동을 바꿀 수 있음 (마치 객체의 클래스가 바뀌는 것과 같은 결과)
        - 상태를 별도의 클래스로 캡슐화
        - 상태를 나타내는 객체에게 행동을 위임
        - 클라이언트는 객체에 대해서 아무 것도 몰라도 됨
    스트래터지 패턴 vs 스테이트 패턴
        - Strategy
            . 클라이언트에서 컨텍스트 객체한테 어떤 전략 객체를 사용할지 지정해줌 (서브 클래스를 만드는 방법을 대신)
              → 실행 시 전략 객체를 변경할 수 있는 유연성 제공
        - State
            . 행동을 상태 객체 내에 캡슐화시켜 컨텍스트 내의 상태 객체를 바꾸는 것만으로도 행동을 바꿀 수 있음
 */